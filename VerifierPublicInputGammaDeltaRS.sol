// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

contract PairingTest {

    // A
    uint256 constant aG1_x =
        14614942786781395235323739941473784359708158727987721451462286880826505164913;
    uint256 constant aG1_y =
        21619883166399935899647001848432357053098942563907854290524692662449417028110;

    // B
    uint256 constant bG2_x1 =
        319587749637165176148886793271196602371225601986791290743038843027662975010;
    uint256 constant bG2_x2 =
        3799125525057959973194726334738911206921416163026998466480194981504341041059;
    uint256 constant bG2_y1 =
        14804322218212369892528022736659815952157535301541362469519071425927767448738;
    uint256 constant bG2_y2 =
        15320077395654528648820749046262517324306647091379407731658843025099270151841;

    // alpha
    uint256 constant alphaG1_x =
        1368015179489954701390400359078579693043519447331113978918064868415326638035;
    uint256 constant alphaG1_y =
        9918110051302171585080402603319702774565515993150576347155970296011118125764;

    // beta
    uint256 constant betaG2_x1 =
        2725019753478801796453339367788033689375851816420509565303521482350756874229;
    uint256 constant betaG2_x2 =
        7273165102799931111715871471550377909735733521218303035754523677688038059653;
    uint256 constant betaG2_y1 =
        2512659008974376214222774206987427162027254181373325676825515531566330959255;
    uint256 constant betaG2_y2 =
        957874124722006818841961785324909313781880061366718538693995380805373202866;

    // C
    uint256 constant cG1_x =
        17701753435269740403921105970374551089935320911024962898677727136701795584514;
    uint256 constant cG1_y =
        14346862312910190547529197118974415823038018600073367279111060787975692996852;

    // delta
    uint256 constant deltaG2_x1 =
        20954117799226682825035885491234530437475518021362091509513177301640194298072;
    uint256 constant deltaG2_x2 =
        4540444681147253467785307942530223364530218361853237193970751657229138047649;
    uint256 constant deltaG2_y1 =
        21508930868448350162258892668132814424284302804699005394342512102884055673846;
    uint256 constant deltaG2_y2 =
        11631839690097995216017572651900167465857396346217730511548857041925508482915;

    // K 
    uint256 constant kG1_x =
        8130355153844137257766966042270012876959861041874487092769493662482126916412;
    uint256 constant kG1_y =
        7803649938864204921881100575346710492955478052315962831459876392649888890679;
    
    // gamma
    uint256 constant gammaG2_x1 =
        18936818173480011669507163011118288089468827259971823710084038754632518263340;
    uint256 constant gammaG2_x2 =
        18556147586753789634670778212244811446448229326945855846642767021074501673839;
    uint256 constant gammaG2_y1 =
        18825831177813899069786213865729385895767511805925522466244528695074736584695;
    uint256 constant gammaG2_y2 =
        13775476761357503446238925910346030822904460488609979964814810757616608848118;

    uint256 constant G2_x1 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant G2_x2 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant G2_y1 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant G2_y2 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;

    uint256 constant Q =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    struct G1Point {
        uint256 x;
        uint256 y;
    }

    function negate(G1Point memory p) internal pure returns (G1Point memory) {
        // The prime q in the base field F_q for G1
        if (p.x == 0 && p.y == 0) return G1Point(0, 0);
        return G1Point(p.x, Q - (p.y % Q));
    }

    function run(bytes memory input) public view returns (bool) {
        // optional, the precompile checks this too and reverts (with no error) if false, this helps narrow down possible errors
        if (input.length % 192 != 0) revert("Points must be a multiple of 6");
        (bool success, bytes memory data) = address(0x08).staticcall(input);
        if (success) return abi.decode(data, (bool));
        revert("Wrong pairing");
    }

    function verify() public view returns (bool) {
        // -A * B + alpha * beta + C * 1(G2) + K * 1(G2) = 0
        bytes memory points1 = abi.encode(
            aG1_x,
            negate(G1Point(aG1_x, aG1_y)).y,
            bG2_x2,
            bG2_x1,
            bG2_y2,
            bG2_y1,
            alphaG1_x,
            alphaG1_y,
            betaG2_x2,
            betaG2_x1,
            betaG2_y2,
            betaG2_y1
        );

        bytes memory points2 = abi.encode(
            cG1_x,
            cG1_y,
            deltaG2_x2,
            deltaG2_x1,
            deltaG2_y2,
            deltaG2_y1,
            kG1_x,
            kG1_y,
            gammaG2_x2,
            gammaG2_x1,
            gammaG2_y2,
            gammaG2_y1
        );

        bytes memory points = abi.encodePacked(points1, points2);
        return run(points);
    }
}
